<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <style>
        body {
            margin: 40px auto;
            line-height: 1.6;
            font-size: 18px;
            color: #333;
            background: #f1f1f1;
            padding: 0 10px
        }

        .description,
        h1,
        h2,
        h3 {
            max-width: 800px;
        }

        h1,
        h2,
        h3 {
            line-height: 1.2
        }

        .mermaid {
            max-width: 1500px;
        }

        .collapsible {
            background-color: #777;
            color: white;
            cursor: pointer;
            padding: 5px;
            border: 2px transparent;
            text-align: left;
            outline: none;
        }

        .active,
        .collapsible:hover {
            background-color: #333;
        }

        .content {
            padding: 0 18px;
            display: none;
            overflow: hidden;
            background-color: #e1e1e1;
        }
    </style>
</head>

<body>
    <h1>Node in the Network</h1>

    <h2>Node's entire lifetime</h2>
    <div class=description>
        <p>This section describes the flow a node will follow during its entire lifetime.<br />
            When they join the network, they won't yet be a member of any section.<br />
            First,they will have to bootstrap with their proxy node, receive a RelocateInfo and attempt to join the
            section that this RelocateInfo is pointing to.<br />
            Once they have a full section, they will be able to operate as a full section member.
        </p>
        <button class="collapsible">OWN_SECTION</button>
        <div class="content">
            <p> OWN_SECTION refers to this node's own section.<br />
                It is an Option&ltPrefix&gt.<br />
                While a node is being relocated, the value will be none. Once they get accepted into a section, it
                becomes Some(that_section_s_prefix)
            </p>
        </div>
        <button class="collapsible">BootstrapAndRelocate</button>
        <div class="content">
            <p>This function gets called when a node just joined the Network.<br />
                At this stage, we are connected to a proxy node and they indicate to us which section we should join.
            </p>
        </div>
        <button class="collapsible">StartSectionMemberNode</button>
        <div class="content">
            <p>Once a node has joined a section (indicated by OWN_SECTION.is_some()), they will be able to perform as a
                member of that section until they are relocated away from it.<br />
                See StartSectionMemberNode graph for details.
            </p>
        </div>
        <button class="collapsible">Rebootstrap</button>
        <div class="content">
            <p>First Create new identity with public key-pair<br />
                The node connects to a proxy with the new identity to use for joining the new section as a full node.
            </p>
        </div>
        <button class="collapsible">JoiningRelocateCandidate</button>
        <div class="content">
            <p>Once a node knows where to be relocated, they will follow this flow to become a full member of the
                section.<br />
                This covers resource proof from the point of view of the node being resource-proofed.<br />
                The output of this function is an Option. If we fail resource proof, it is none, which means we will
                have to bootstrap again. If it is Some, it contains the RelocateInfo we need to join this section.<br />
                See JoiningRelocateCandidate graph for details.
            </p>
        </div>
    </div>
    <div class="mermaid">
        graph TB

        Start --> LoopStart
        style Start fill:#f9f,stroke:#333,stroke-width:4px

        LoopStart --> HasSection
        HasSection(("Check?"))

        HasSection --"OWN_SECTION.is_none()"--> BootstrapAndRelocate
        BootstrapAndRelocate["BootstrapAndRelocate:<br />Get RelocateInfo"]
        BootstrapAndRelocate --> ReBootstrapWithNewIdentity

        HasSection --"OWN_SECTION.is_some()"--> StartSectionMemberNode
        StartSectionMemberNode["StartSectionMemberNode<br />"]
        style StartSectionMemberNode fill:#f9f,stroke:#333,stroke-width:4px
        StartSectionMemberNode --> ReBootstrapWithNewIdentity

        ReBootstrapWithNewIdentity["Rebootstrap<br />with new relocated identity<br />output: RelocateInfo"]
        ReBootstrapWithNewIdentity --> JoiningRelocateCandidate

        JoiningRelocateCandidate["JoiningRelocateCandidate(RelocateInfo)<br />output: JoiningApproved"]
        style JoiningRelocateCandidate fill:#f9f,stroke:#333,stroke-width:4px

        SetNodeApproval["OWN_SECTION=JoiningApproved"]
        JoiningRelocateCandidate --> SetNodeApproval

        SetNodeApproval --> LoopEnd
        LoopEnd --> LoopStart
    </div>

    <h2>Becoming a full member of a section</h2>
    <div class=description>
        This is from the point of view of a node trying to join a section as a full member.<br />
        This node is going to connect, send Rpc::CandidateInfo, and then perform the resource proof until it receives a Rpc::NodeApproval to complete this stage
        successfully.<br />
        If the node is not accepted, after time out, it will try another section as a new node.
        <button class="collapsible">TimeoutResendInfo</button>
        <div class="content">
            <p>Timeout triggered to resend messages that have not been replied to:<br/>
                Either Rpc::ConnectionInfoRequest or Rpc::CandidateInfo
            </p>
        </div>
        <button class="collapsible">TimeoutRefused</button>
        <div class="content">
            <p>Timeout to stop trying to resource proof if so much time has elapsed that we will not be able to succeed.
            </p>
        </div>
        <button class="collapsible">get_next_resource_proof_part</button>
        <div class="content">
            <p>Return the next part of the resource proof for the given elder.<br />
                inputs:<br />
                - elder name<br />
            </p>
        </div>
        <button class="collapsible">get_connected_and_unconnected</button>
        <div class="content">
            <p>Return connected nodes and unconnected nodes in the given collection.<br />
                inputs:<br />
                - elder names<br />
            </p>
        </div>
        <button class="collapsible">has_resource_proof_for</button>
        <div class="content">
            <p>Return true if we already received Rpc::ResourceProof for that node.<br />
                inputs:<br />
                - elder name<br />
            </p>
        </div>
        <button class="collapsible">RELOCATED_INFO</button>
        <div class="content">
            <p>The RelocatedInfo given to the routine and used to send CandidateInfo
            </p>
        </div>
    </div>
    <div class="mermaid">
        graph TB
        LoopStart --> WaitFor

        JoiningRelocateCandidate --> InitialSendConnectionInfoRequest
        JoiningRelocateCandidate["JoiningRelocateCandidate<br />(Take RelocatedInfo)"]
        style JoiningRelocateCandidate fill:#f9f,stroke:#333,stroke-width:4px

        InitialSendConnectionInfoRequest["RELOCATED_INFO = RelocatedInfo<br/>
        schedule(TimeoutRefused)"]

        WaitFor(("Wait for 0:"))
        LocalEvent((Local<br />Event))
        WaitFor --> LocalEvent

        InitialSendConnectionInfoRequest-->CheckResend
        LocalEvent--"TimeoutResendInfo triggered"--> CheckResend
        CheckResend["(connected, unconnected) =<br/>get_connected_and_unconnected(<br/>RELOCATED_INFO.section_info)<br/>
        <br/>
        For node in unconnected:<br/>
        send_rpc(ConnectionInfoRequest) to node<br/>
        <br/>
        For node in connected:<br/>
        if !has_resource_proof_for(node):<br/>
        send_rpc(<br/>Rpc::CandidateInfo from RELOCATED_INFO)<br/>to node<br/>
        <br/>
        schedule(TimeoutResendInfo)"]
        CheckResend --> LoopEnd


        LocalEvent -- ResourceProofForElderReady --> SendNextResourceProofPartForElder
        SendNextResourceProofPartForElder["send_rpc(<br />Rpc::ResourceProofResponse{<br />get_next_resource_proof_part(<br />elder
        name)})"]
        SendNextResourceProofPartForElder --> LoopEnd

        LocalEvent--"TimeoutRefused<br />triggered"--> EndRoutine
        EndRoutine["End of JoiningRelocateCandidate<br />"]
        style EndRoutine fill:#f9f,stroke:#333,stroke-width:4px

        Rpc((RPC))
        WaitFor --> Rpc
        Rpc -- Rpc::NodeApproval --> EndRoutine

        Rpc -- ConnectionInfoResponse --> ConnectAndSendCandidateInfo
        ConnectAndSendCandidateInfo["send_rpc(<br/>Rpc::CandidateInfo from RELOCATED_INFO)"]
        ConnectAndSendCandidateInfo-->LoopEnd

        Rpc -- Rpc::ResourceProofReceipt --> SendNextResourceProofPartForElder

        Rpc -- Rpc::ResourceProof --> StartComputeResourceProofForElder
        StartComputeResourceProofForElder["start_compute_resource_proof(<br />source elder)"]
        StartComputeResourceProofForElder --> LoopEnd

        Rpc --
        "Rpc::ExpectCandidate<br />Rpc::ExpectCandidateRefuseResponse<br />Rpc::ExpectCandidateAcceptResponse<br />..."
        --> VoteParsecRPC
        VoteParsecRPC["vote_for(the parsec rpc)<br />(cache for later)"]
        VoteParsecRPC --> LoopEnd

        LoopEnd --> LoopStart

    </div>

    <h2>Node as a member of a section</h2>
    <div class=description>
        <p>Once a node has joined a section, they need to be ready to take on multiple roles simultaneously:<br />
            <ul>
                <li> Deal with relocation:<br />
                    The section as a whole will sometimes act as the source and sometimes as the destination of
                    relocations. This means nodes will sometimes relocate away from this section and sometimes relocate
                    to this section. Nodes in this section will need to perform the right flow to deal with both of
                    these situations.
                <li> Decide who's an elder or a plain old adult as well as when to merge or split.
                <li> Decide who is online and offline.
            </ul>
            All of these flows are happening simultaneously, but they share a common event loop. At any time, either all
            flows or all but one flows must be in a "wait" state. (If an event is handled by multiple active event
            loops, the one with the highest number handles it.)<br />
            If our section decides to relocates us, we will have to stop functioning as a member of our section and go
            back to the previous flow where we will "Rebootstrap" so we can become a member of a different section.
        </p>
    </div>
    <div class="mermaid">
        graph TB
        style StartSectionMemberNode fill:#f9f,stroke:#333,stroke-width:4px
        style EndRoutine fill:#f9f,stroke:#333,stroke-width:4px
        StartSectionMemberNode --> InitialiseNodeInternalState
        InitialiseNodeInternalState["initialise_node_internal_state()<br /><br />(Parsed, Routing table...)"]
        InitialiseNodeInternalState --> ConcurrentStartElder

        ConcurrentStartElder{"Concurrent<br />start elder"}

        ConcurrentStartElder --> ConcurrentStartSrc
        ConcurrentStartSrc{"Concurrent<br />start src"}

        ConcurrentStartSrc --> StartDecidesOnNodeToRelocate
        style StartDecidesOnNodeToRelocate fill:#f9f,stroke:#333,stroke-width:4px

        ConcurrentStartSrc --> StartRelocateSrc
        style StartRelocateSrc fill:#f9f,stroke:#333,stroke-width:4px


        ConcurrentStartElder --> ConcurrentStartDst
        ConcurrentStartDst{"Concurrent<br />start dst"}

        ConcurrentStartDst --> StartRespondToRelocateRequests
        style StartRespondToRelocateRequests fill:#f9f,stroke:#333,stroke-width:4px

        ConcurrentStartDst --> StartResourceProof
        StartResourceProof[StartResourceProof]
        style StartResourceProof fill:#f9f,stroke:#333,stroke-width:4px

        ConcurrentStartElder --> StartMergeSplitAndChangeElders
        style StartMergeSplitAndChangeElders fill:#f9f,stroke:#333,stroke-width:4px

        ConcurrentStartElder --> CheckOnlineOffline
        style CheckOnlineOffline fill:#f9f,stroke:#333,stroke-width:4px

        ConcurrentStartElder --> StartConnectionHandler
        style StartConnectionHandler fill:#f9f,stroke:#333,stroke-width:4px

        ConcurrentStartElder --> WaitFor

        WaitFor(("Wait for 0:"))

        Rpc((RPC))
        WaitFor --> Rpc
        Rpc -- "Rpc::RelocatedInfo"--> EndRoutine
        EndRoutine["EndRoutine: Kill all sub routines"]
    </div>

    <h1>Destination section</h1>
    <div class=description>
        <p>As a member of a section, our section will sometimes receive a node that is being relocated. These diagrams
            are from the point of view of one of the nodes in the section, doing its part to handle the node that is
            trying to relocate to this section.
        </p>
    </div>
    <h2>Deciding when to accept an incoming relocation</h2>
    <div class=description>
        <p>This flow represents what we do when a section contacts us to relocate one of their nodes to our
            section.<br />
            The process starts as we receive an Rpc::ExpectCandidate from this node.<br />
            We vote for it in PARSEC to be sure all members of the section process it in the same order.<br />
            Once it reaches consensus, we are ready to process that candidate by letting them connect (see
            StartRelocatedNodeConnection) and then perform the resource_proof (see StartResourceProof).<br />
            There are some subtleties, such as the fact that we only want to process one candidate at a time, but this
            is the general idea.
        </p>
        <button class="collapsible">Rpc::ExpectCandidate</button>
        <div class="content">
            <p>We receive this RPC from a section that wants to relocate a node to our section.<br />
                The node is not communicating with us yet, only once we sent Rpc::ExpectCandidateAcceptResponse to the
                originating section.<br />
                On receiving it, we vote for Parsec::ExpectCandidate to process it in the same order as other members of
                our section.<br />
                It kickstarts the entire chain of events in this diagram.<br />
                Note that we could also see consensus on Parsec::ExpectCandidate before we ourselves voted for it in
                PARSEC, as long as enough members of our section did.
            </p>
        </div>
        <button class="collapsible">count_waiting_proofing_or_hop</button>
        <div class="content">
            <p>We want to accept at most one incoming relocation at a time into our section.<br />
                The count_waiting_proofing_or_hop function returns the count of nodes that we have yet to resource proof
                or relocate through a new hop, (States from State::WaitingCandidateInfo until it reaches State::Online
                or State::Relocated).<br />
                When the output of this function is not 0 and we reach consensus on Parsec::ExpectCandidate, we send a
                Rpc::ExpectCandidateRefuseResponse to the would-be-incoming-node so they can try another section or try
                again later.
            </p>
        </div>
        <button class="collapsible">get_waiting_candidate_info</button>
        <div class="content">
            <p>If we already accepted a candidate, reply with the same info we provided intially and returned by
                get_waiting_candidate_info.
            </p>
        </div>
        <button class="collapsible">shorter_prefix_section</button>
        <div class="content">
            <p>If we know of a section that has a shorter prefix than ours, we prefer for them to receive this incoming
                node rather than ourselves as it will help keep the Network's sections tree balanced.<br />
                This shorter_prefix_section is a function that will return None if we are the shortest of any section we
                know, Some if there is a better candidate.<br />
                If it is Some, we will relocate the new node to them instead of completing the relocation to our own
                section.
            </p>
        </div>
    </div>
    <div class="mermaid">
        graph TB

        Start["StartRespondToRelocateRequests:<br />No exit - Needs killed"]
        style Start fill:#f9f,stroke:#333,stroke-width:4px
        Start --> LoopStart
        LoopEnd --> LoopStart


        LoopStart --> WaitFor

        WaitFor((Wait for 1:))
        WaitFor --RPC--> RPC
        WaitFor --Parsec<br />consensus--> ParsecConsensus

        RPC((RPC))
        RPC --Rpc::ExpectCandidate--> VoteParsecExpectCandidate

        ParsecConsensus((Consensus))
        ParsecConsensus --Parsec::ExpectCandidate--> Balanced

        VoteParsecExpectCandidate["vote_for(<br />Parsec::ExpectCandidate)"]
        VoteParsecExpectCandidate --> LoopEnd

        Balanced(("Check"))
        Balanced -- "shorter_prefix_section(<br />).is_some()" --> RelocateToShorterPrefix
        RelocateToShorterPrefix["send_rpc(<br />Rpc::ExpectCandidate)<br />to shorter prefix section"]
        RelocateToShorterPrefix --> LoopEnd

        Balanced -- "Otherwise" --> HasCandidate
        HasCandidate(("Check"))
        HasCandidate -- "get_waiting_candidate_info(candidate).is_some()" --> SendIdenticalExpectCandidateAcceptResponse
        HasCandidate -- "count_waiting_proofing_or_hop()==0" --> SendExpectCandidateAcceptResponse
        HasCandidate -- "Otherwise" --> SendRefuse

        SendIdenticalExpectCandidateAcceptResponse["send_rpc(<br />Rpc::ExpectCandidateAcceptResponse)<br />again to
        source section<br />with original info<br />get_waiting_candidate_info(candidate)"]
        SendIdenticalExpectCandidateAcceptResponse --> LoopEnd

        SendExpectCandidateAcceptResponse["add_node(<br />NodeState=State::WaitingCandidateInfo)<br /><br />send_rpc(<br />Rpc::ExpectCandidateAcceptResponse)<br />to
        source section"]
        SendExpectCandidateAcceptResponse --> LoopEnd

        SendRefuse["send_rpc(<br />Rpc::ExpectCandidateRefuseResponse)<br />to source section"]
        SendRefuse --> LoopEnd


    </div>

    <h2>Resource proof from a destination's point of view</h2>
    <div class=description>
        <p>Manage node with NodeState=State::WaitingCandidateInfo.<br />
           When we periodically decide to resource proof a node, we check if any node is ready for it:
           State::WaitingCandidateInfo state.<br />
            <br />
            Once the candidate is connected, it sends its CandidateInfo to each Elders it was given in RelocatedInfo.<br />
            As an elder, I will send the candidate a Rpc::ResourceProof. This gives them the "problem to solve". As they
            solve it, they will send me ResourceProofResponses. These will be parts of the proof. On receiving valid
            parts, I must send a ResourceProofReceipt. Once they finally send me the last valid part, they passed their
            resource proof and I vote for Parsec::Online (essentially accepting them as a member of my section).<br />
            At any time during this process, they may timeout (The whole process it taking longer than expected), in
            which case I will decided to reject them and vote for Parsec::PurgeCandidate.<br />
            This process ends once I reach consensus on either accepting the candidate (Parsec::Online) or refusing them
            (Parsec::PurgeCandidate).<br />
            It is possible that both reach the quorum consensus, in which case the second one will be discarded. It
            won't cause issues as consistency is the only property that matters here: if we accept someone who then went
            Offline, we will be able to detect they are Offline later with the standard Offline detection mechanism. But
            it is more likely that they took close to the time limit to complete their proof.
        </p>
        <button class="collapsible">is_valid_waited_info</button>
        <div class="content">
            <p>Return true if
                <ul>
                    <li> The given CandidateInfo is valid,
                    <li> It matches one of our nodes that is in the State::WaitingCandidateInfo state,
                    <li> The message_src (from the current RPC) is consistent with the CandidateInfo's new_public_id
                </ul>
            </p>
        </div>
        <button class="collapsible">resource_proof_candidate</button>
        <div class="content">
            <p>Return a candidate ready to be resource proofed (First node in State::WaitingCandidateInfo state)
            </p>
        </div>
        <button class="collapsible">update_to_node</button>
        <div class="content">
            <p>Convert the candidate node at the target interval address to a node using the new_public_id.
                Update the state of the node with the given state.
            </p>
        </div>
        <button class="collapsible">CANDIDATE</button>
        <div class="content">
            <p>Option&lt(Candidate)&gt.<br />
               The candidate we are currently resource proofing old_public_id, if any.
            </p>
        </div>
        <button class="collapsible">VOTED_ONLINE</button>
        <div class="content">
            <p>Once we've voted a node online, we don't care to handle further ResourceProofResponses from them.<br />
                This local variable helps us with this.
            </p>
        </div>
        <button class="collapsible">Rpc::ResourceProofResponse</button>
        <div class="content">
            <p>The candidate sends this RPC that contains part of a proof. It may continue to be sent by a node we have
                not accepted, even if consensus was reached to add it.<br />
                It may also still be sent by a candidate we have rejected. It's OK to discard the RPC in these cases as
                it is no longer relevant.
            </p>
        </div>
        <button class="collapsible">Parsec::Online<br />Parsec::PurgeCandidate</button>
        <div class=content>
            <p>The same node could be accepted by some nodes who would vote Parsec::Online, but also time out for some
                other nodes who would vote for Parsec::PurgeCandidate.<br />
                If it's the case, we only want to process the first of these two events and discard the other one.
            </p>
        </div>
        <button class="collapsible">ResourceProof_Cancel</button>
        <div class="content">
            <p>Provides an external entry point to cancel the currently processed nodes: Restart the resource proofing
                with all involved voters.<br />
                This will be called for example after merge/split as the new nodes would become voters.
            </p>
        </div>
    </div>
    <div class="mermaid">
        graph TB
        ResourceProof["StartResourceProof"]
        style ResourceProof fill:#f9f,stroke:#333,stroke-width:4px

        ResourceProof --> StartCheckResourceProofTimeout
        StartCheckResourceProofTimeout["schedule(<br />CheckResourceProofTimeout)"]
        StartCheckResourceProofTimeout --> LoopStart

        WaitFor(("Wait for 3:"))

        LoopStart-->WaitFor

        WaitFor -- Parsec<br />consensus--> ParsecConsensus
        ParsecConsensus((Consensus))
        ParsecConsensus --Parsec::Online<br />Parsec::PurgeCandidate<br />otherwise--> DiscardParsec
        DiscardParsec["Discard<br />Parsec<br />event"]
        DiscardParsec --> LoopEnd

        ParsecConsensus -- Parsec::PurgeCandidate<br />for CANDIDATE --> RemoveNode
        ParsecConsensus -- Parsec::Online<br />for CANDIDATE --> MakeOnline
        MakeOnline["update_to_node(<br />Parsec::Online info,<br />Parsec::Online new_public_id,<br />State::Online)<br /><br />send_rpc(<br />Rpc::NodeApproval)"]
        RemoveNode["purge_node_info(<br />candidate node)"]
        RemoveNode --> ReStartCheckResourceProofTimeout
        MakeOnline --> ReStartCheckResourceProofTimeout

        ParsecConsensus -- "Parsec::CheckResourceProof" --> SetCandidate
        SetCandidate["CANDIDATE=resource_proof_candidate()"]
        SetCandidate -->CheckRequestRP

        CheckRequestRP((Check))
        CheckRequestRP --"Otherwise" --> ReStartCheckResourceProofTimeout
        ReStartCheckResourceProofTimeout["CANDIDATE=None<br />CANDIDATE_INFO=None<br/>VOTED_ONLINE==no<br /><br />schedule(<br />CheckResourceProofTimeout)"]
        ReStartCheckResourceProofTimeout --> LoopEnd

        CheckRequestRP --"CANDIDATE.is_some()"--> ScheduleTimer
        ScheduleTimer["schedule(<br />TimeoutAccept)"]
        ScheduleTimer --> LoopEnd

        RPC((RPC))
        WaitFor --RPC--> RPC
        RPC -- "Rpc::CandidateInfo<br/>and<br/>is_valid_waited_info(<br/>CandidateInfo)<br/>and<br/>CANDIDATE==<br/>CandidateInfo.old_public_id" --> RequestRP
        RequestRP["CANDIDATE_INFO=<br/>Some(CandidateInfo)<br/><br/>send_rpc(<br />Rpc::ResourceProof)<br />to CANDIDATE_INFO.new_public_id"]
        RequestRP --> LoopEnd

        RPC -- Rpc::ResourceProofResponse<br />from CANDIDATE_INFO --> ProofResponse((Proof))
        ProofResponse((Check))
        SendProofReceipt["send_rpc(<br />Rpc::ResourceProofReceipt)<br />for proof"]
        ProofResponse -- "Valid Part or End<br />otherwise" --> SendProofReceipt
        VoteParsecOnline["vote_for(<br />Parsec::Online)<br /><br />VOTED_ONLINE=yes"]
        ProofResponse -- "Valid End<br />and<br />VOTED_ONLINE==no" --> VoteParsecOnline
        VoteParsecOnline --> SendProofReceipt
        SendProofReceipt-->LoopEnd

        DiscardRPC[Discard RPC]
        RPC -- "Rpc::CandidateInfo<br/>or<br/>Rpc::ResourceProofResponse<br/>otherwise" --> DiscardRPC
        DiscardRPC --> LoopEnd

        WaitFor --Event--> Event
        Event((Event))
        VoteParsecPurgeCandidate["vote_for(<br />Parsec::PurgeCandidate)"]
        Event -- TimeoutAccept<br />expire --> VoteParsecPurgeCandidate

        VoteParsecCheckResourceProofTimeout["vote_for(<br />Parsec::CheckResourceProof)"]
        Event -- CheckResourceProofTimeout<br />expire --> VoteParsecCheckResourceProofTimeout
        VoteParsecCheckResourceProofTimeout --> LoopEnd

        VoteParsecPurgeCandidate --> LoopEnd
        LoopEnd --> LoopStart

    </div>
    <div class="mermaid">
        graph TB

        Cancel["ResourceProof_Cancel"]
        style Cancel fill:#19f,stroke:#333,stroke-width:4px

        EndCancel["End ResourceProof_Cancel"]
        style EndCancel fill:#19f,stroke:#333,stroke-width:4px

        Cancel --> CancelCheckResourceProofTimeout
        CancelCheckResourceProofTimeout["CANDIDATE=None<br />CANDIDATE_INFO=None<br/>VOTED_ONLINE==no<br/><br />purge_node_info(CANDIDATE)<br />schedule(<br />CheckResourceProofTimeout)"]
        CancelCheckResourceProofTimeout --> EndCancel
    </div>

    <h1>Source section</h1>
    <div class=description>
        <p>As members of a section, each node must keep track of how many "work units" other nodes have performed.<br />
            Once a node has accumulated enough work units to gain age, the section must work together to relocate that
            node to a new section where they can become 1 age unit older.<br />
            These diagrams detail how this happens.
        </p>
    </div>
    <h2>Deciding that a member of our section should be relocated away</h2>
    <div class=description>
        <p>In these diagrams, we are modelling the simple version of node ageing that we decided to implement for
            Fleming: Work units are incremented for all nodes in the section every time a timeout reaches
            consensus.<br />
            Because a quorum of elders must have voted for this timeout, the malicious nodes can't arbitrarily speed up
            the ageing of their nodes.<br />
            Once a node has accumulated enough work units to be relocated, if no other node is currently in
            State::RelocatingAgeIncrease we set its state to State::RelocatingAgeIncrease. This node will then be
            actually relocated in StartRelocateSrc (see StartRelocateSrc).
            Because of this, we will generally only relocate one adult at a time (except in case of merge).
        </p>
        <button class="collapsible">WorkUnitTimeout</button>
        <div class="content">
            <p>In the context of Fleming, nodes (especially adults) aren't doing meaningful work such as handling
                data.<br />
                As a proxy, we use a time based metric to estimate how much work nodes have done (i.e: how long they
                remained in State::Online and responsive).<br />
                A local timeout wouldn't do here as it would allow malicious nodes to artificially age nodes in their
                sections faster. However, by reaching quorum on the fact a timeout happened, we ensure that at least one
                honest node has voted for the timeout.<br />
                All nodes start the WorkUnitTimeout. On expiry, they vote for a WorkUnitIncrement in PARSEC and restart
                the timer.
            </p>
        </div>
        <button class="collapsible">increment_nodes_work_units</button>
        <div class="content">
            <p>This function increments the number of work units for all members of my peer_list (remember that
                n_work_units is a member of the PeerState struct).<br />
            </p>
        </div>
        <button class="collapsible">has_relocating_node</button>
        <div class="content">
            <p>Returns true if we have any node currently relocating: With node state State::RelocatingAgeIncrease
                only.<br />
                There will most often be zero or one such nodes, unless a merge occurs in which case there may be
                multiple.
                Nodes coming back online, or needing an extra hop are not considered here.
            </p>
        </div>
        <button class="collapsible">get_node_to_relocate</button>
        <div class="content">
            <p>This function will return the best candidate for relocation, if any.<br />
                First, it will only consider members of our peer_list that have the state: State::Online<br />
                We use the condition with has_relocating_node() to limit the number of State::Online nodes to relocate
                to one (except possibly in case of a merge).<br />
                It can return for instance the node with the largest number of work units for which the number of work
                units is greater than 2^age.
            </p>
        </div>
        <button class="collapsible">set_node_state</button>
        <div class="content">
            <p>This function mutates our peer_list to set the state (for example set State::RelocatingAgeIncrease for
                the node).<br />
                inputs:<br />
                - node<br />
                - state<br />
                side-effect:<br />
                - mutates peer_list
            </p>
        </div>
    </div>
    <div class="mermaid">
        graph TB

        Start["StartDecidesOnNodeToRelocate:<br />No exit - Needs killed"]
        style Start fill:#f9f,stroke:#333,stroke-width:4px
        Start --> StartWorkUnitTimeOut

        StartWorkUnitTimeOut["schedule(WorkUnitTimeOut)"]
        StartWorkUnitTimeOut --> LoopStart
        LoopEnd --> LoopStart

        LoopStart --> WaitFor

        WaitFor((Wait for 4:))
        WaitFor --Event--> Event
        WaitFor --Parsec<br />consensus--> ParsecConsensus

        Event((Event))
        Event -- WorkUnitTimeOut<br />Trigger --> VoteParsecRelocationTrigger
        VoteParsecRelocationTrigger["vote_for(Parsec::WorkUnitIncrement)<br />schedule(WorkUnitTimeOut)"]
        VoteParsecRelocationTrigger --> LoopEnd

        ParsecConsensus((Consensus))
        ParsecConsensus -- Parsec::WorkUnitIncrement --> IncrementWorkUnit
        IncrementWorkUnit["increment_nodes_work_units()"]
        IncrementWorkUnit-->AlreadyRelocating
        AlreadyRelocating(("Check?"))


        AlreadyRelocating --"get_node_to_relocate().is_some()<br />and<br />!has_relocating_node()"-->
        SetRelocatingNodeState
        AlreadyRelocating --"Otherwise"--> LoopEnd

        SetRelocatingNodeState["set_node_state(<br />get_node_to_relocate(),<br />State::RelocatingAgeIncrease)"]
        SetRelocatingNodeState --> LoopEnd
    </div>

    <h2>Relocating a member of our section away from it</h2>
    <div class=description>
        <p>At this stage, we handle nodes that were marked for relocation.<br />
            <br />
            We send an Rpc::ExpectCandidate to the destination section:<br />
            Either that section will send us a Rpc::ExpectCandidateAcceptResponse, then we will complete the node
            relocation.<br />
            Or that section will send us a Rpc::ExpectCandidateRefuseResponse, then we will retry later.<br />
            Or that RPC or the response is lost, then we will retry later.<br />
            <br />
            When we receive Rpc::ExpectCandidateAcceptResponse or Rpc::ExpectCandidateRefuseResponse, we vote for it in
            PARSEC, regardless of the order of operations, so it will be consensused.<br />
            The first Parsec::ExpectCandidateAcceptResponse consensused for a node will be the single valid relocation.
            We will sign the relocation info through parsec and send to the node that is being relocated the
            RelocatedInfo they will need.<br />
            At this point, we will purge their information since this node isn't a member of our section any more.<br />
            <br />
            Elders are not considered for relocation: Elder nodes in State::RelocatingAgeIncrease will eventually get
            demoted to adults (see StartMergeSplitAndChangeElders) at which point they may be relocated.<br />
            We prioritise relocating our Adults, then just relocated nodes that need another hop, then nodes coming back
            online.<br />
            <br />
            Also of note: We may be relocating multiple nodes (i.e because of merge, or node relocating to us or node
            coming back online), but we will only handle one at a time per CheckRelocateTimeOut event.<br />
            Throttling is otherwise handled in flows setting the relocating states.
        </p>
        <button class="collapsible">get_best_relocating_node_and_target</button>
        <div class="content">
            <p>Takes ALREADY_RELOCATING for the nodes it will ignore.<br />
                Returns the best node to relocate and the target address to send it to<br />
                <br />
                There may be multiple nodes relocating, for example because of a merge. Take the best one (oldest), and
                choose a target address.<br />
                The target address is one managed by one of our neighbours. This could be random, or the current
                old_public_id with a single bit of the prefix flipped.<br />
                This would help ensure that source and destination remain neighbours, even if the source splits.<br />
                Using a target address instead of a section ensures we deliver the message even if the destination
                splits or merges.<br />
                <br />
                There are 3 states the node may be: State::RelocatingAgeIncrease, State::RelocatingHop, and
                State::RelocatingBackOnline.<br />
                Nodes will be selected in this order: State::RelocatingAgeIncrease, State::RelocatingHop and then
                State::RelocatingBackOnline and tie break by age then name.<br />
                This ensures that we prioritise good node relocation.
                <br />
                Note: It may be possible for a node to relocate to its sibling, and complete relocation after a merge
                occurred.
            </p>
        </div>
        <button class="collapsible">ALREADY_RELOCATING</button>
        <div class="content">
            <p>The nodes we ignore when selecting a new node to send Rpc::ExpectCandidate for.<br />
                Local states are not carried over on merge or split, so we will resend Rpc::ExpectCandidate earlier than
                we would otherwise.
            </p>
        </div>
        <button class="collapsible">is_our_relocating_node</button>
        <div class="content">
            <p>Is it a valid node that is not yet relocated (i.e State is State::RelocatingAgeIncrease,
                State::RelocatingHop or State::RelocatingBackOnline).
            </p>
        </div>
        <button class="collapsible">Rpc::ExpectCandidateRefuseResponse/Rpc::ExpectCandidateAcceptResponse</button>
        <div class="content">
            <p>Exactly one of these RPCs will be sent to us from the destination section as a response to our section's
                Rpc::ExpectCandidate.<br />
                When this happens, we will immediately vote for it in PARSEC as we need to act in the same order as
                anyone else in our section.<br />
                In case we re-sent the Rpc::ExpectCandidate, we may receive more than one
                Rpc::ExpectCandidateRefuseResponse and Rpc::ExpectCandidateAcceptResponse. In this case we will pass on
                the first Rpc::ExpectCandidateAcceptResponse to our Candidate.<br />
            </p>
        </div>
        <button class="collapsible">Rpc::RelocatedInfo</button>
        <div class="content">
            <p>Trigger relocation: Candidate will disconnect on receiving that RPC<br />
                This RPC contains the Rpc::ExpectCandidateAcceptResponse info, and the signatures proving the source
                section received it and decided that particular response is the one to relocate to.<br />
                In case we re-sent the Rpc::ExpectCandidate, we may receive more than one
                Rpc::ExpectCandidateAcceptResponse.<br />
                In this case we must ensure that no single node could act on that other
                Rpc::ExpectCandidateAcceptResponse and be accepted by the destination. this means the signatures must be
                provided only once the Rpc::ExpectCandidateAcceptResponse is agreed.<br />
                RelocatedInfo will contain the Rpc::ExpectCandidateAcceptResponse info and the quorum of signatures
                gathered from PARSEC vote on Parsec::RelocatedInfo.
            </p>
        </div>
    </div>
    <div class="mermaid">
        graph TB
        Start["StartRelocateSrc:<br />No exit - Needs killed"]
        style Start fill:#f9f,stroke:#333,stroke-width:4px
        Start --> StartCheckRelocateTimeOut

        StartCheckRelocateTimeOut["schedule(CheckRelocateTimeOut)"]
        StartCheckRelocateTimeOut --> LoopStart
        LoopEnd --> LoopStart

        LoopStart --> WaitFor

        WaitFor((Wait for 5:))
        WaitFor --Event--> Event
        WaitFor --RPC--> RPC
        WaitFor --Parsec<br />consensus--> ParsecConsensus

        Event((Event))
        Event -- CheckRelocateTimeOut<br />Trigger --> VoteParsecCheckRelocate
        VoteParsecCheckRelocate["vote_for(<br />Parsec::CheckRelocate)<br />schedule(<br />CheckRelocateTimeOut)"]
        VoteParsecCheckRelocate --> LoopEnd

        RPC((RPC))
        RPC --Rpc::ExpectCandidateAcceptResponse--> VoteParsecExpectCandidateAcceptResponse
        RPC --Rpc::ExpectCandidateRefuseResponse--> VoteParsecExpectCandidateRefuseResponse
        VoteParsecExpectCandidateAcceptResponse["vote_for(<br />Parsec::ExpectCandidateAcceptResponse)"]
        VoteParsecExpectCandidateAcceptResponse --> LoopEnd
        VoteParsecExpectCandidateRefuseResponse["vote_for(<br />Parsec::ExpectCandidateRefuseResponse))"]
        VoteParsecExpectCandidateRefuseResponse --> LoopEnd

        ParsecConsensus((Consensus))
        ParsecConsensus -- Parsec::CheckRelocate --> CheckNeedRelocate
        CheckNeedRelocate((Check?))
        CheckNeedRelocate--"Otherwise" -->AllowResendCandidates

        CheckNeedRelocate--"get_best_relocating_node_and_target(<br />ALREADY_RELOCATING).is_some()" -->
        SendExpectCandidate
        SendExpectCandidate["(node,
        target)=<br />get_best_relocating_node_and_target(<br />ALREADY_RELOCATING)<br /><br />send_rpc(<br />Rpc::ExpectCandidate(node))<br />to
        target NaeManager<br /><br />ALREADY_RELOCATING<br />.insert(node)"]
        SendExpectCandidate --> AllowResendCandidates

        AllowResendCandidates["ALREADY_RELOCATING=<br />ALREADY_RELOCATING<br />.map(|(node, count| (node,
        count+1))<br />.filter(|(node,count|) count
        < 3)<br /><br />(update wait and allow resend)"]
        AllowResendCandidates --> LoopEnd


        ParsecConsensus --"Parsec::ExpectCandidateAcceptResponse<br />Parsec::ExpectCandidateRefuseResponse" -->
        CheckIsOurs
        CheckIsOurs((Check))
        CheckIsOurs -- "is_our_relocating_node(node)" --> CheckIsAccept
        CheckIsAccept((Check))
        CheckIsAccept -- Parsec::ExpectCandidateRefuseResponse --> RefusedCandidate
        RefusedCandidate["ALREADY_RELOCATING<br />.remove(node)<br /><br />(allow resend)"]
        RefusedCandidate --> LoopEnd

        CheckIsAccept -- Parsec::ExpectCandidateAcceptResponse --> VoteProvableRelocateInfo
        VoteProvableRelocateInfo["set_node_state(<br />node,<br />State::Relocated{accept_info}<br />(Vote for same
        relocation if merge/split<br />so only one valid proof
        exists)<br /><br />vote_for(<br />Parsec::RelocatedInfo{accept_info})<br /><br />(set relocated and prepare
        info)"]
        VoteProvableRelocateInfo --> LoopEnd


        CheckIsOurs -- Otherwise --> DiscardVote
        DiscardVote[Discard<br />Vote]
        DiscardVote --> LoopEnd

        ParsecConsensus --"Parsec::RelocatedInfo"--> SendProvableRelocateInfo
        SendProvableRelocateInfo["send_rpc(Rpc::RelocatedInfo)<br />to node<br /><br />Node may be already gone"]
        SendProvableRelocateInfo-->PurgeNodeInfos
        PurgeNodeInfos["purge_node_info(<br />node)"]
        PurgeNodeInfos--> LoopEnd
    </div>

    <h1>Elder-only</h1>

    <h2>Process handling connections</h2>
    <div class=description>
        <p>This flow handles receiving connection requests. It will also handle establishing connections in the future.<br />
        </p>

        <button class="collapsible">ConnectionInfoRequest/ConnectionInfoResponse</button>
        <div class="content">
            <p>Sent to collect information needed to establish a direct connection: Unchanged
            </p>
        </div>
    </div>
    <div class="mermaid">
        graph TB
        StartConnectionHandler["StartConnectionHandler:<br />No exit - Needs killed"]
        style StartConnectionHandler fill:#f9f,stroke:#333,stroke-width:4px

        StartConnectionHandler --> LoopStart
        LoopStart --> WaitFor

        WaitFor((Wait for 6:))
        WaitFor --RPC--> RPC

        RPC -- Rpc::ConnectionInfoRequest --> OnConnectionInfoRequest
        OnConnectionInfoRequest["send_rpc(<br />Rpc::ConnectionInfoResponse)"]
        OnConnectionInfoRequest --> LoopEnd

        LoopEnd --> LoopStart
    </div>


    <h2>Process for Adult/Elder promotion and demotion including merge</h2>
    <div class=description>
        <p>This flow updates the elder status of our section nodes if needed.<br />
            Because it is interlinked, it also handles merging and splitting section: When merging or splitting, no
            elder change can happen.<br />
            However other flows continue, so relocating to and from the section is uninterrupted:<br />
        </p>

        <button class="collapsible">CheckElderTimeout</button>
        <div class="content">
            <p>As for incrementing work units, we want to update the eldership status of all nodes in a section on a
                synchronised, regular basis.<br />
                For this reason, it makes sense to have a timer going through Parsec.<br />
                Note that this timer has to be only as fast as needed so that it remains highly unlikely that 1/3 of the
                elders in any section would go offline within one timer's duration.
            </p>
        </div>
        <button class="collapsible">Rpc::Merge</button>
        <div class="content">
            <p>A section sends a Rpc::Merge to their neighbour section when they are ready to merge at the given
                SectionInfo digest. The RPC contains the SectionInfo of the originating section.<br />
                In this flow, we handle both situations:<br>
                <ul>
                    <li> Our neighbour triggers the merge and we receive their Rpc::Merge.<br>
                        We then vote for Parsec::NeighbourMerge.
                    <li> We trigger the merge ourselves (see ProcessMerge flow)
                </ul>
            </p>
        </div>
        <button class="collapsible">Parsec::NeighbourMerge</button>
        <div class="content">
            <p>We vote for this Parsec event on receiving a Rpc::Merge from our neighbour section.<br>
                It contains the information about them that we need for merging. When this PARSEC event reaches
                consensus in PARSEC, we store that information by calling store_merge_infos.
            </p>
        </div>
        <button class="collapsible">store_merge_infos</button>
        <div class="content">
            <p>This function is used to store the merge information from a neighbour section locally.<br>
                Once it has been stored, has_merge_infos will return true and we will be ready to enter the ProcessMerge
                flow.
            </p>
        </div>
        <button class="collapsible">has_merge_infos</button>
        <div class="content">
            <p>This function indicates that we received sufficient information from our neighbour section needing a
                merge, and reached consensus on it.<br>
                We are ready to start the merging process with them.
            </p>
        </div>
        <button class="collapsible">merge_needed</button>
        <div class="content">
            <p>This function indicates that we need merging (as opposed to a merge triggered by our neighbour's
                needs).<br>
                The details for the trigger are still in slight flux, but here are some possibilities:
                <ul>
                    <li> The number of State::Online adults plus elders is below our min section size of 10 elder plus
                        90 Adults
                    <li> A certain proportion of the adults in this section are marked Offline
                </ul>
            </p>
        </div>
        <button class="collapsible">check_elder_change</button>
        <div class="content">
            <p>If any of our elders is not State::Online, they must be demoted to a plain old adult.<br />
                If this happens, the oldest adult must be promoted to the elder state as a replacement.<br />
                Alternatively, if any of our State::Online adult nodes is older than any of our elders, the youngest
                elder must be demoted and this adult must be promoted.<br />
                Note that elder changes are only processed when the section is not in the middle of handling a merge.
            </p>
        </div>
        <button class="collapsible">split_needed</button>
        <div class="content">
            <p>This function indicates that we need splitting.<br>
                The details for the trigger are still in slight flux, but here are some possibilities:
                <ul>
                    <li> The number of State::Online adults plus elders is above our min section size of 10 elder plus 90
                        Adults + buffer
                </ul>
            </p>
        </div>
        <button class="collapsible">checkpoint_needed</button>
        <div class="content">
            <p>This function indicates that we need to checkpoint due to an over bloated Parsec instance.<br>
            This would not be necesary if either ProcessSplit or ProcessMerge is active.
            </p>
        </div>
    </div>
    <div class="mermaid">
        graph TB
        StartMergeSplitAndChangeElders["StartMergeSplitAndChangeElders:<br />No exit - Needs killed"]
        style StartMergeSplitAndChangeElders fill:#f9f,stroke:#333,stroke-width:4px

        StartMergeSplitAndChangeElders --> StartCheckElderTimeout
        StartCheckElderTimeout["schedule(<br />CheckElderTimeout)"]
        StartCheckElderTimeout --> LoopStart


        WaitFor(("Wait for 6:"))
        LoopStart --> WaitFor

        WaitFor -- Event --> Event
        Event((Event))
        Event-- CheckElder<br />Timeout--> VoteCheckElderTimeout
        VoteCheckElderTimeout["vote_for(<br />Parsec::CheckElderTimeout)"]
        VoteCheckElderTimeout--> LoopEnd

        RPC((RPC))
        WaitFor -- RPC --> RPC
        RPC --Rpc::Merge--> VoteParsecNeighbourMerge
        VoteParsecNeighbourMerge["vote_for(<br />Parsec::NeighbourMerge)"]
        VoteParsecNeighbourMerge --> LoopEnd

        Consensus((Consensus))
        WaitFor-- Parsec<br />consensus --> Consensus

        Consensus -- "Parsec::NeighbourMerge" --> SetNeighbourMerge
        SetNeighbourMerge["store_merge_infos(<br />Parsec::NeighbourMerge info)"]
        SetNeighbourMerge-->LoopEnd

        Consensus--"Parsec::CheckElderTimeout"-->CheckMergeNeeded
        CheckMergeNeeded(("Check"))

        CheckMergeNeeded--"Otherwise"-->CheckElderChange
        CheckElderChange(("Check"))

        CheckElderChange -- "Otherwise" --> CheckNeedSplit
        CheckNeedSplit(("Check"))

        CheckNeedSplit --"Otherwise" --> CheckNeedCheckPoint
        CheckNeedCheckPoint(("Check"))

        CheckNeedCheckPoint --"Otherwise" --> RestartTimeout
        RestartTimeout["schedule(<br />CheckElderTimeout)"]
        RestartTimeout-->LoopEnd

        CheckNeedCheckPoint -- "checkpoint_needed()" --> Concurrent3
        Concurrent3{"Concurrent<br />paths"}
        Concurrent3 --> ProcessCheckPoint
        Concurrent3 --> LoopEnd

        ProcessCheckPoint["ProcessCheckPoint"]
        style ProcessCheckPoint fill:#f9f,stroke:#333,stroke-width:4px
        ProcessCheckPoint --> CancelResourceProof

        CheckNeedSplit --"split_needed()" --> Concurrent2
        Concurrent2{"Concurrent<br />paths"}
        Concurrent2 --> ProcessSplit
        Concurrent2 --> LoopEnd

        ProcessSplit["ProcessSplit"]
        style ProcessSplit fill:#f9f,stroke:#333,stroke-width:4px
        ProcessSplit --> CancelResourceProof

        CheckElderChange --"check_elder_change()<br /><br />Has elder changes: elder first ordered
        by:<br />NodeState==State::Online then age then name."--> Concurrent0
        Concurrent0{"Concurrent<br />paths"}
        Concurrent0 --> ProcessElderChange
        Concurrent0 --> LoopEnd

        ProcessElderChange["ProcessElderChange(changes)"]
        style ProcessElderChange fill:#f9f,stroke:#333,stroke-width:4px
        ProcessElderChange -->CancelResourceProof


        CancelResourceProof["ResourceProof_Cancel"]
        style CancelResourceProof fill:#19f,stroke:#333,stroke-width:4px
        CancelResourceProof --> ResetRelocatedNodeConnection

        ResetRelocatedNodeConnection["RelocatedNodeConnection_Reset"]
        style ResetRelocatedNodeConnection fill:#19f,stroke:#333,stroke-width:4px
        ResetRelocatedNodeConnection --> RestartTimeout

        CheckMergeNeeded --"merge_needed()<br />or<br />has_merge_infos()"-->Concurrent1
        Concurrent1{"Concurrent<br />paths"}
        Concurrent1 --> ProcessMerge
        Concurrent1 --> LoopEnd

        ProcessMerge["ProcessMerge"]
        style ProcessMerge fill:#f9f,stroke:#333,stroke-width:4px
        ProcessMerge --> CancelResourceProof

        LoopEnd --> LoopStart
    </div>

    <h2>Process Adult/Elder promotion and demotion needed from last check</h2>
    <div class=description>
        <p>Vote for Parsec::Add for new elders,Parsec:: Remove for no longer elders and Parsec::NewSectionInfo<br />
            This handles any change, it does not care whether one or all elders are changed, this is decided by the
            calling function.
        </p>
        <button class="collapsible">WAITED_VOTES</button>
        <div class="content">
            <p>At any time, there must be exactly NUM_ELDERS (say 10) elders per section.<br>
                To maintain this invariant, we must handle multiple eldership changes atomically<br>
                We accomplish this by voting for all the membership changes needed at once and waiting for all these
                votes to reach consensus before reflecting the status change in our chain.<br>
            </p>
        </div>
        <button class="collapsible">new_section_info</button>
        <div class="content">
            <p>A list of PublicId.<br>
                The content of the NewSectionInfo parsec event that reached consensus.
            </p>
        </div>
        <button class="collapsible">update_elder_status</button>
        <div class="content">
            <p>This function updates the eldership status of each node in the chain based on the new section info: the
                nodes with their public id in new_section_info are the exact set of current elders.<br>
                Input:
                <ul>
                    <li>new_section_info: Set&ltPublicId&gt<br>
                        The new section info that just reached consensus.
                </ul>
                Side-effect:
                <ul>
                    <li>Mutates the chain.
                </ul>
            </p>
        </div>
    </div>
    <div class="mermaid">
        graph TB
        ProcessElderChange["ProcessElderChange<br />(Take elder changes)<br />(shared state)"]
        style ProcessElderChange fill:#f9f,stroke:#333,stroke-width:4px

        EndRoutine["End of ProcessElderChange<br />(shared state)"]
        style EndRoutine fill:#f9f,stroke:#333,stroke-width:4px

        ProcessElderChange --> MarkAndVoteSwapNewElder
        MarkAndVoteSwapNewElder["vote_for(Parsec::Add) for new elders<br />vote_for(Parsec::Remove) for now adults
        nodes<br />vote_for(Parsec::NewSectionInfo)<br /><br />WAITED_VOTES.insert(all votes)"]
        MarkAndVoteSwapNewElder --> LoopStart

        WaitFor(("Wait for 7:"))
        LoopStart --> WaitFor

        Consensus((Consensus))
        WaitFor-- Parsec<br />consensus --> Consensus

        Consensus -- "WAITED_VOTES.contains(vote)" --> OneVoteConsensused
        OneVoteConsensused["WAITED_VOTES.remove(vote)"]

        OneVoteConsensused --> WaitComplete
        WaitComplete(("Check?"))
        WaitComplete--"WAITED_VOTES<br />.is_empty()<br />(Wait complete)"-->MarkNewElderAdults
        MarkNewElderAdults["update_elder_status(new_section_info)"]
        MarkNewElderAdults--> EndRoutine
        WaitComplete--"!WAITED_VOTES<br />.is_empty()<br />(Wait not complete)"--> LoopEnd

        LoopEnd --> LoopStart
    </div>

    <h2>Handling merges</h2>
    <div class=description>
        <p>Send Rpc::Merge, and take over handling any Parsec::NeighbourMerge.<br />
            Complete when one merge has completed, and a NewSectionInfo is consensused.<br />
            If multi-stage merges are required, they will require calling this function again<br />
            While in this sanctuary, our SectionInfo shall not be disturbed by elder changes.
            This stops us from changing our SectionInfo after indicating to our neighbour the last SectionInfo before
            merge.
        </p>
        <button class="collapsible">Rpc::Merge</button>
        <div class="content">
            <p>We send it to our sibling section (or sections with longer prefix) on entering ProcessMerge, containing our own SectionInfo.<br>
                We send Merge irrespective of whether we are the section that triggered the merge. This allows all
                sections involved in the merge to receive a Rpc::Merge, which is how Parsec::NeighbourMerge gets voted
                for.
            </p>
        </div>
        <button class="collapsible">Parsec::NeighbourMerge</button>
        <div class="content">
            <p>This PARSEC event indicates that our neighbour section is ready to merge with us.<br>
                It is voted for in the StartMergeSplitAndChangeElders flow, on receipt of a Rpc::Merge.<br>
                It contains their SectionInfo (or digest for it).<br>
            </p>
        </div>
        <button class="collapsible">store_merge_infos</button>
        <div class="content">
            <p>Store the neighbour's merge info, may not be sibling in case of multi merge<br />
            </p>
        </div>
        <button class="collapsible">has_sibling_merge_info</button>
        <div class="content">
            <p>Did we store the neighbour's merge info for our sibling<br />
            </p>
        </div>
        <button class="collapsible">merge_sibling_info_to_new_section</button>
        <div class="content">
            <p>Remove the stored sibling's merge info and return the NewSectionInfo.<br />
            </p>
        </div>
        <button class="collapsible">Parsec::NewSectionInfo</button>
        <div class="content">
            <p>Once we are ready to merge, have received our neighbour's SectionInfo through their Rpc::Merge, and
                subsequently reached consensus on the Parsec::NeighbourInfo we voted for, we have all the information
                needed to decide on the membership of our post-merge section.<br>
                This is the Parsec::NewSectionInfo.
            </p>
        </div>
        <button class="collapsible">complete_merge</button>
        <div class="content">
            <p>With the Parsec::NewSectionInfo in hands, completing the merge process consists on joining the newly
                formed section and leaving the old one behind.
            </p>
        </div>
    </div>
    <div class="mermaid">
        graph TB
        EndRoutine["End of ProcessMerge<br />(shared state)"]
        style EndRoutine fill:#f9f,stroke:#333,stroke-width:4px


        LoopStart --> WaitFor
        WaitFor(("Wait for 8:"))

        Consensus((Consensus))
        WaitFor-- Parsec<br />consensus --> Consensus
        Consensus -- "Parsec::NewSectionInfo" --> CompleteMerge
        CompleteMerge["complete_merge()<br />(Start parsec with new genesis...)"]
        CompleteMerge --> MarkNewElderAdults

        MarkNewElderAdults["update_elder_status(new_section_info)"]
        MarkNewElderAdults--> EndRoutine

        Consensus -- "Parsec::NeighbourMerge" --> SetNeighbourMerge
        SetNeighbourMerge["store_merge_infos(Parsec::NeighbourMerge info)"]
        SetNeighbourMerge --> CheckMerge

        ProcessMerge["ProcessMerge<br />(shared state)"]
        style ProcessMerge fill:#f9f,stroke:#333,stroke-width:4px
        ProcessMerge --> SendMergeRpc
        SendMergeRpc["send_rpc(Rpc::Merge)"]
        SendMergeRpc --> CheckMerge

        CheckMerge((Check))
        CheckMerge -- "has_sibling_merge_info()" --> VotForNewSectionInfo
        VotForNewSectionInfo["merge_sibling_info_to_new_section()<br />vote_for(Parsec::NewSectionInfo)"]
        VotForNewSectionInfo--> LoopEnd

        CheckMerge -- "Otherwise" --> LoopEnd

        LoopEnd --> LoopStart
    </div>

    <h2>Handling splits</h2>
    <div class=description>
        <p>Vote for the two Parsec::NewSectionInfo to gather required signatures<br />
        </p>
        <button class="collapsible">WAITED_VOTES</button>
        <div class="content">
            <p>Wait for all these votes to reach consensus before reflecting the status change in our chain.<br>
                Both sections need to be consensused before we move on so we do not leave one behind with not enough
                voters.
            </p>
        </div>
        <button class="collapsible">complete_split</button>
        <div class="content">
            <p>With the NewSectionInfo in hands, completing the split process consists on joining the correct newly
                formed section and leaving the old one behind.
            </p>
        </div>
        <button class="collapsible">new_section_info</button>
        <div class="content">
            <p>A list of PublicId.<br>
                The content of the NewSectionInfo parsec event that reached consensus that we are now a member of.
            </p>
        </div>
    </div>
    <div class="mermaid">
        graph TB
        ProcessSplit["ProcessSplit<br />(Take elder changes)<br />(shared state)"]
        style ProcessSplit fill:#f9f,stroke:#333,stroke-width:4px

        EndRoutine["End of ProcessSplit<br />(shared state)"]
        style EndRoutine fill:#f9f,stroke:#333,stroke-width:4px

        ProcessSplit --> VoteNewSections
        VoteNewSections["vote_for(Parsec::NewSectionInfo) for the two new sections<br /><br />WAITED_VOTES.insert(all
        votes)"]
        VoteNewSections --> LoopStart

        WaitFor(("Wait for 9:"))
        LoopStart --> WaitFor

        Consensus((Consensus))
        WaitFor-- Parsec<br />consensus --> Consensus

        Consensus -- "WAITED_VOTES.contains(vote)" --> OneVoteConsensused
        OneVoteConsensused["WAITED_VOTES.remove(vote)"]

        OneVoteConsensused --> WaitComplete
        WaitComplete(("Check?"))
        WaitComplete--"WAITED_VOTES<br />.is_empty()<br />(Wait complete)"-->CompleteSplit
        CompleteSplit["complete_split()<br />(Start parsec with new genesis...)"]
        CompleteSplit --> MarkNewElderAdults

        MarkNewElderAdults["update_elder_status(new_section_info)"]
        MarkNewElderAdults--> EndRoutine

        WaitComplete--"!WAITED_VOTES<br />.is_empty()<br />(Wait not complete)"--> LoopEnd
        LoopEnd --> LoopStart
    </div>

    <h2>Handling check points</h2>
    <div class=description>
        <p>Check point to deal with growing Parsec. Effectively creating a new section with a new Parsec but same members as before.<br />
        </p>
        <button class="collapsible">WAITED_VOTES</button>
        <div class="content">
            <p>Wait for the vote to reach consensus before reflecting the status change in our chain.<br>
            </p>
        </div>
        <button class="collapsible">complete_check_point</button>
        <div class="content">
            <p>With the NewSectionInfo in hands, completing the check point process by joining the new section.
            </p>
        </div>
    </div>
    <div class="mermaid">
        graph TB
        ProcessCheckPoint["ProcessCheckPoint<br />(shared state)"]
        style ProcessCheckPoint fill:#f9f,stroke:#333,stroke-width:4px

        EndRoutine["End of ProcessCheckPoint<br />(shared state)"]
        style EndRoutine fill:#f9f,stroke:#333,stroke-width:4px

        ProcessCheckPoint --> VoteNewSections
        VoteNewSections["vote_for(Parsec::NewSectionInfo) for the new section with a restarted Parsec instance<br /><br />WAITED_VOTES.insert(vote)"]
        VoteNewSections --> LoopStart

        WaitFor(("Wait for 10:"))
        LoopStart --> WaitFor

        Consensus((Consensus))
        WaitFor-- Parsec<br />consensus --> Consensus

        Consensus -- "WAITED_VOTES.contains(vote)" --> OneVoteConsensused
        OneVoteConsensused["WAITED_VOTES.remove(vote)"]

        OneVoteConsensused --> WaitComplete
        WaitComplete(("Check?"))
        WaitComplete--"WAITED_VOTES<br />.is_empty()<br />(Wait complete)"-->CompleteSplit
        CompleteSplit["complete_check_point()<br />(Start parsec with new genesis...)"]
        CompleteSplit --> EndRoutine

        WaitComplete--"!WAITED_VOTES<br />.is_empty()<br />(Wait not complete)"--> LoopEnd
        LoopEnd --> LoopStart
    </div>

    <h2>Handling members of our section going online or offline</h2>
    <div class=description>
        <button class="collapsible">State::RelocatingBackOnline</button>
        <div class="content">
            <p>A nodes state indicating that it is relocated with age reduced as it went offline.<br />
            </p>
        </div>
    </div>
    <div class="mermaid">
        graph TB
        CheckOnlineOffline["CheckOnlineOffline:<br />No exit - Needs killed"]
        style CheckOnlineOffline fill:#f9f,stroke:#333,stroke-width:4px

        CheckOnlineOffline --> LoopStart

        WaitFor(("Wait for 11:"))
        LoopStart --> WaitFor

        LocalEvent((Local<br />Event))
        WaitFor --event--> LocalEvent

        LocalEvent -- Node detected offline --> VoteNodeOffline
        VoteNodeOffline["vote_for(<br />Parsec::Offline)"]
        VoteNodeOffline --> LoopEnd

        LocalEvent -- Node detected back online --> VoteNodeBackOnline
        VoteNodeBackOnline["vote_for(<br />Parsec::BackOnline)"]
        VoteNodeBackOnline --> LoopEnd

        Consensus((Consensus))
        WaitFor-- Parsec<br />consensus --> Consensus
        Consensus--"Parsec::Offline"-->SetOfflineState
        SetOfflineState["set_node_state(<br />node,<br />State::Offline)"]
        SetOfflineState -->LoopEnd

        Consensus -- "Parsec::BackOnline" --> SetRelocating
        SetRelocating["set_node_state(<br />node,<br />State::RelocatingBackOnline)"]

        SetRelocating --> LoopEnd
        LoopEnd --> LoopStart
    </div>

    <h1>Node relocation overview</h1>

    <h2>Successfully relocate a node from source to destination section</h2>
    <div class=description>
        <button class="collapsible">ExpectCandidate</button>
        <div class="content">
            <p>Sent by the source section when a candidate needs to relocate<br />
                Contains:<br />
                <ul>
                    <li>old_public_id: PublicId - The joining node's current public ID.<br>
                    <li>new_age: u8 - The joining node's new public id age. <br>
                        Decided by source section, could be +1 or /2 depending on why we relocate.<br>
                        (If we want to allow early relocate, we could also add carried over work units.)
                </ul>
            </p>
        </div>
        <button class="collapsible">ExpectCandidateAcceptResponse</button>
        <div class="content">
            <p>Sent by destination section when a candidate is accepted<br />
                Contains:<br />
                <ul>
                    <li>target_interval: (XorName, XorName) - The interval into which the joining node should join.<br>
                    <li>section_info: SectionInfo - The destination section that the joining node will trust.<br>
                </ul>
            </p>
        </div>
        <button class="collapsible">ExpectCandidateRefuseResponse</button>
        <div class="content">
            <p>Sent by destination section when a candidate is refused<br />
                Contains: Empty
            </p>
        </div>
        <button class="collapsible">RelocatedInfo</button>
        <div class="content">
            <p>Sent by source section when a candidate is relocated to the relocated node<br />
                Contains:<br />
                <ul>
                    <li>target_interval: (XorName, XorName) - The interval into which the joining node should join.<br>
                    <li>section_info: SectionInfo - The destination section that the joining node will trust and connect to.<br>
                    <li>proof: Signatures - Quorum of signature for the candidate to prove the source section relocated
                        it with these infos.<br>
                </ul>
            </p>
        </div>
        <button class="collapsible">CandidateInfo</button>
        <div class="content">
            <p>Sent by the joining node to each elders of the section it is joining to initiate the joining process<br />
                Contains:<br />
                <ul>
                    <li>old_public_id: PublicId - PublicId from before relocation.<br>
                    <li>new_public_id: PublicId - PublicId from after relocation.<br>
                    <li>signature_using_old: Signature - Signature of concatenated PublicIds using the pre-relocation
                        key.<br>
                    <li>signature_using_new: Signature - Signature of concatenated PublicIds and signature_using_old
                        using the post-relocation key.<br>
                    <li>new_client_auth: Authority - Client authority from after relocation.<br>
                    <li>source_proof: Signatures - Quorum of signature from the source section proving the source
                        approved that relocation.<br>
                        This will be checked against the stored information in the candidate node state.<br />
                </ul>
            </p>
        </div>
        <button class="collapsible">ConnectionInfoRequest/ConnectionInfoResponse</button>
        <div class="content">
            <p>Sent to collect information needed to establish a direct connection: Unchanged
            </p>
        </div>
        <button class="collapsible">ResourceProof/ResourceProofResponse/ResourceProofReceipt</button>
        <div class="content">
            <p>Sent to process resource proof: Unchanged<br />
            </p>
        </div>
        <button class="collapsible">NodeApproval</button>
        <div class="content">
            <p>Sent by destination section when a candidate becomes an adult / resource proof is completed.<br />
                Contains: Empty (Any information needed by an adult/elder should be sent to all connected members, and
                updated as it changes)
            </p>
        </div>
    </div>
    <div class="mermaid">
        sequenceDiagram
        participant Src as Source Section
        participant Node as Relocating Node
        participant Dst as Destination Section


        loop FindDestination
        Src->>+Dst: Routing RPC: Rpc::ExpectCandidate
        opt Refuse
        Dst-->>Src: Routing RPC: Rpc::ExpectCandidateRefuseResponse
        end
        end
        Dst-->>-Src: Routing RPC: Rpc::ExpectCandidateAcceptResponse
        Src->>Node: Direct node-to-node RPC: Rpc::RelocatedInfo

        loop NodeConnection
        Node->>+Dst: Proxied Routing RPC: Rpc::ConnectionInfoRequest
        Dst-->>-Node: Proxied Routing RPC: Rpc::ConnectionInfoResponse
        Node->>Dst: Direct node-to-node RPC to group: Rpc::CandidateInfo
        end

        Dst->>Node: Direct node-to-node RPC: Rpc::ResourceProof
        loop ResProof
        Node->>+Dst: Direct node-to-node RPC: Rpc::ResourceProofResponse
        Dst-->>-Node: Direct node-to-node RPC: Rpc::ResourceProofReceipt
        end

        Dst->>Node: Unproxied Group RPC: Rpc::NodeApproval
    </div>

    <script src="mermaid.min.js"></script>
    <script>mermaid.initialize({ sequence: { width: 400, actorMargin: 100, boxTextMargin: 50, messageMargin: 50 }, startOnLoad: true });</script>
    <script>
        var coll = document.getElementsByClassName("collapsible");
        var i;

        for (i = 0; i < coll.length; i++) {
            coll[i].addEventListener("click", function () {
                this.classList.toggle("active");
                var content = this.nextElementSibling;
                if (content.style.display === "block") {
                    content.style.display = "none";
                } else {
                    content.style.display = "block";
                }
            });
        }
    </script>
</body>

</html>
